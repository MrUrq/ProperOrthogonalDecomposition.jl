<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>POD · ProperOrthogonalDecomposition.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="ProperOrthogonalDecomposition.jl logo"/></a><h1>ProperOrthogonalDecomposition.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li class="current"><a class="toctext" href="POD.html">POD</a><ul class="internal"><li><a class="toctext" href="#Method-of-snapshots-1">Method of snapshots</a></li><li><a class="toctext" href="#Singular-Value-Decomposition-based-method-1">Singular Value Decomposition based method</a></li><li><a class="toctext" href="#Example-1">Example</a></li></ul></li><li><a class="toctext" href="weightedPOD.html">Weighted POD</a></li><li><a class="toctext" href="convergence.html">Mode convergence</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="POD.html">POD</a></li></ul><a class="edit-page" href="https://github.com/MrUrq/ProperOrthogonalDecomposition.jl/blob/master/docs/src/man/POD.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>POD</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="POD-1" href="#POD-1">POD</a></h1><p>Each method returns a tuple containing the pod basis of type <code>PODBasis{T}</code> and  the corresponding singular values. The singular values are related to each modes importance to the dataset. </p><h2><a class="nav-anchor" id="Method-of-snapshots-1" href="#Method-of-snapshots-1">Method of snapshots</a></h2><p>The eigen-decomposition based <em>method of snapshots</em> is the most commonly used  method for fluid flow analysis where the number of datapoints is larger than the number of snapshots.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProperOrthogonalDecomposition.PODeigen-Tuple{Any}" href="#ProperOrthogonalDecomposition.PODeigen-Tuple{Any}"><code>ProperOrthogonalDecomposition.PODeigen</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">PODeigen(X)</code></pre><p>Uses the eigenvalue method of snapshots to calculate the POD basis of X. Method of snapshots is efficient when number of data points <code>n</code> &gt; number of snapshots <code>m</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/MrUrq/ProperOrthogonalDecomposition.jl/blob/606f8ee8217960c994c9b9096b1ec40bef6af09c/src/PODeigen.jl#L2-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProperOrthogonalDecomposition.PODeigen!-Tuple{Any}" href="#ProperOrthogonalDecomposition.PODeigen!-Tuple{Any}"><code>ProperOrthogonalDecomposition.PODeigen!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">PODeigen!(X)</code></pre><p>Same as <code>PODeigen(X)</code> but overwrites memory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/MrUrq/ProperOrthogonalDecomposition.jl/blob/606f8ee8217960c994c9b9096b1ec40bef6af09c/src/PODeigen.jl#L71-L75">source</a></section><h2><a class="nav-anchor" id="Singular-Value-Decomposition-based-method-1" href="#Singular-Value-Decomposition-based-method-1">Singular Value Decomposition based method</a></h2><p>The SVD based approach is also available and is more robust against roundoff errors. </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProperOrthogonalDecomposition.PODsvd-Tuple{Any}" href="#ProperOrthogonalDecomposition.PODsvd-Tuple{Any}"><code>ProperOrthogonalDecomposition.PODsvd</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">PODsvd(X)</code></pre><p>Uses the SVD based decomposition technique to calculate the POD basis of X. </p></div></div><a class="source-link" target="_blank" href="https://github.com/MrUrq/ProperOrthogonalDecomposition.jl/blob/606f8ee8217960c994c9b9096b1ec40bef6af09c/src/PODsvd.jl#L2-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProperOrthogonalDecomposition.PODsvd!-Tuple{Any}" href="#ProperOrthogonalDecomposition.PODsvd!-Tuple{Any}"><code>ProperOrthogonalDecomposition.PODsvd!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">PODsvd!(X)</code></pre><p>Same as <code>PODsvd(X)</code> but overwrites memory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/MrUrq/ProperOrthogonalDecomposition.jl/blob/606f8ee8217960c994c9b9096b1ec40bef6af09c/src/PODsvd.jl#L27-L31">source</a></section><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>Here we will artifically create data which is PODed and then extract the first mode.</p><div><pre><code class="language-julia">t, x = range(0, stop=30, length=50), range(-10, stop=30, length=120)

Xgrid = [i for i in x, j in t]
tgrid = [j for i in x, j in t]

f1 = sech.(Xgrid.-3.5) .* 10.0 .* cos.(0.5 .*tgrid)
f2 = cos.(Xgrid) .* 1.0 .* cos.(2.5 .*tgrid)
f3 = sech.(Xgrid.+5.0) .* 4.0 .* cos.(1.0 .*tgrid)

Y = f1+f2+f3</code></pre></div><p>Our data <code>Y</code> looks like this</p>    <iframe src="../assets/poddata.html" height="540" width="765" frameborder="0" seamless="seamless" scrolling="no"></iframe><p>Now we POD the data and reconstruct the dataset using only the first mode.</p><div><pre><code class="language-julia">res, singularvals  = POD(Y)
reconstructFirstMode = res.modes[:,1:1]*res.coefficients[1:1,:]</code></pre></div><p>Note that the above used <code>POD(Y)</code> which defaults to the SVD based apparoch. The first mode over the time series looks like this</p>    <iframe src="../assets/podfirstmode.html" height="540" width="765" frameborder="0" seamless="seamless" scrolling="no"></iframe><footer><hr/><a class="previous" href="../index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="weightedPOD.html"><span class="direction">Next</span><span class="title">Weighted POD</span></a></footer></article></body></html>
